/*********
  ESP32 NEO-6M GPS Datalogger with Async Web Server
  Reads GPS data, saves to LittleFS CSV, serves async webpage with last location and CSV download.
  Tested with ESP32 core 3.0.5 + lacamera ESP Async WebServer v1.2.3.
*********/

#include <WiFi.h>  // Explicit for AP mode
#include <ESPAsyncWebServer.h>
#include <LittleFS.h>
#include <TinyGPSPlus.h>
#include <HardwareSerial.h>

#ifndef ARDUINO_EVENT_WIFI_STA_GOT_IP
#define ARDUINO_EVENT_WIFI_STA_GOT_IP IP_EVENT_STA_GOT_IP
#define ARDUINO_EVENT_WIFI_STA_DISCONNECTED WIFI_EVENT_STA_DISCONNECTED
#endif

// GPS Configuration
#define RXD2 16
#define TXD2 17
#define GPS_BAUD 9600
TinyGPSPlus gps;
HardwareSerial gpsSerial(2);
// LED Configuration (for serial activity indicator)
#define LED_PIN 2
// WiFi AP Configuration
const char* ssid = "UlTeRa_SpAcE";
const char* password = "12345678";

// Async Web Server
AsyncWebServer server(80);

// Data Storage
const char* dataPath = "/gpslog.csv";
const char* CSV_HEADER = "UTC Time,Latitude,Longitude,Altitude(m),Speed(km/h),Satellites";
String lastLat = "0.000000";
String lastLng = "0.000000";
String lastTime = "No fix yet";

String lastSpeedKmph = "0.0";
String lastAltitudeMeters = "0.0";
String lastCourseDeg = "N/A";
String lastSatellites = "0";
String lastHdop = "N/A";
String lastFixAgeMs = "N/A";

// System information variables
String freeHeapStr = "0";
String totalHeapStr = "0";
String usedHeapStr = "0";
String flashSizeStr = "0";
String flashSpeedStr = "0";
String cpuFreqStr = "0";
String littleFSTotalStr = "0";
String littleFSUsedStr = "0";
String littleFSFreeStr = "0";
String chipModelStr = "ESP32";
String uptimeStr = "0s";

// --- Logging policy/config ---
const unsigned long LOG_MAX_INTERVAL_MS = 30UL * 1000UL; // maximum time between logged points (30s heartbeat)
const double SIGNIFICANT_DISTANCE_METERS = 10.0; // minimum distance change to consider (meters)

// Storage management
const size_t MAX_LOG_FILE_SIZE = 640 * 1024; // trim when >64KB
const size_t LOG_TRIM_KEEP_BYTES = 320 * 1024; // keep the newest ~32KB of log entries when trimming
const float STORAGE_HIGH_WATERMARK = 0.90; // fraction used of LittleFS to trigger cleanup

struct KnownNetwork {
  const char* ssid;
  const char* password;
};

const KnownNetwork knownNetworks[] = {
  // TODO: update with your trusted hotspots
  {"mixura", "@@@sadra@@@sadra@@@min"},
  {"YourOfficeWiFi", "office-password"}
};
const size_t KNOWN_NETWORK_COUNT = sizeof(knownNetworks) / sizeof(knownNetworks[0]);

bool stationConnected = false;
String stationIpStr = "Not connected";
String currentStationSsid = "";
String apIpStr = "";

const unsigned long WIFI_SCAN_INTERVAL_MS = 60UL * 1000UL; // rescan for known networks every minute
const unsigned long WIFI_CONNECT_TIMEOUT_MS = 10000UL;
unsigned long lastWifiScanMillis = 0;

// Runtime state for logging decisions
bool hasLastLogged = false;
double lastLoggedLat = 0.0;
double lastLoggedLng = 0.0;
unsigned long lastLoggedMillis = 0;
unsigned long lastStorageCheckMillis = 0;
const unsigned long STORAGE_CHECK_INTERVAL_MS = 600UL * 1000UL; // check storage every 2 minutes (reduced frequency)

// Small helper: Haversine distance (meters)
double haversineDistance(double lat1, double lon1, double lat2, double lon2) {
  const double R = 6371000.0; // Earth radius in meters
  double dLat = (lat2 - lat1) * DEG_TO_RAD;
  double dLon = (lon2 - lon1) * DEG_TO_RAD;
  double a = sin(dLat/2) * sin(dLat/2) + cos(lat1 * DEG_TO_RAD) * cos(lat2 * DEG_TO_RAD) * sin(dLon/2) * sin(dLon/2);
  double c = 2 * atan2(sqrt(a), sqrt(1 - a));
  return R * c;
}

void onWiFiEvent(WiFiEvent_t event) {
  switch (event) {
    case ARDUINO_EVENT_WIFI_STA_GOT_IP:
      stationConnected = true;
      stationIpStr = WiFi.localIP().toString();
      currentStationSsid = WiFi.SSID();
      Serial.printf("Station connected, IP: %s\n", stationIpStr.c_str());
      break;
    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
      if (stationConnected) {
        Serial.println("Station disconnected. Attempting reconnect...");
      }
      stationConnected = false;
      stationIpStr = "Not connected";
      currentStationSsid = "";
      WiFi.reconnect();
      break;
    default:
      break;
  }
}

bool attemptConnectToKnownNetworks() {
  if (KNOWN_NETWORK_COUNT == 0) {
    Serial.println("No known networks configured.");
    return false;
  }

  Serial.println("Scanning for known WiFi hotspots...");
  int16_t networkCount = WiFi.scanNetworks();
  if (networkCount <= 0) {
    Serial.println("No WiFi networks detected.");
    return false;
  }

  int bestKnownIndex = -1;
  int bestKnownRssi = -1000;
  for (int i = 0; i < networkCount; ++i) {
    String foundSsid = WiFi.SSID(i);
    for (size_t k = 0; k < KNOWN_NETWORK_COUNT; ++k) {
      if (foundSsid == knownNetworks[k].ssid) {
        int rssi = WiFi.RSSI(i);
        if (rssi > bestKnownRssi) {
          bestKnownRssi = rssi;
          bestKnownIndex = static_cast<int>(k);
        }
      }
    }
  }

  if (bestKnownIndex == -1) {
    Serial.println("No known hotspots in range.");
    return false;
  }

  const KnownNetwork& chosen = knownNetworks[bestKnownIndex];
  Serial.printf("Attempting connection to %s (RSSI %d dBm)\n", chosen.ssid, bestKnownRssi);
  WiFi.begin(chosen.ssid, chosen.password);

  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < WIFI_CONNECT_TIMEOUT_MS) {
    delay(250);
    Serial.print('.');
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    stationConnected = true;
    currentStationSsid = String(chosen.ssid);
    stationIpStr = WiFi.localIP().toString();
    Serial.printf("Connected to %s, IP %s\n", currentStationSsid.c_str(), stationIpStr.c_str());
    WiFi.setAutoReconnect(true);
    return true;
  }

  Serial.println("Connection attempt failed.");
  WiFi.disconnect(true);
  return false;
}

void maintainWiFi() {
  wl_status_t status = WiFi.status();
  if (status != WL_CONNECTED) {
    if (stationConnected) {
      stationConnected = false;
      stationIpStr = "Not connected";
      currentStationSsid = "";
    }
    if (KNOWN_NETWORK_COUNT == 0) {
      return;
    }
    unsigned long now = millis();
    if (now - lastWifiScanMillis >= WIFI_SCAN_INTERVAL_MS) {
      lastWifiScanMillis = now;
      attemptConnectToKnownNetworks();
    }
  } else if (!stationConnected) {
    stationConnected = true;
    stationIpStr = WiFi.localIP().toString();
    currentStationSsid = WiFi.SSID();
  }
}

// Trim the current log file to keep only the newest entries (single-file policy)
void trimLogFile() {
  if (!LittleFS.exists(dataPath)) return;
  File file = LittleFS.open(dataPath, FILE_READ);
  if (!file) return;

  size_t fileSize = file.size();
  if (fileSize <= MAX_LOG_FILE_SIZE) {
    file.close();
    return;
  }

  String header = file.readStringUntil('\n');
  String remaining = file.readString();
  file.close();

  size_t keepBytes = LOG_TRIM_KEEP_BYTES;
  if (keepBytes == 0 || keepBytes > remaining.length()) {
    keepBytes = remaining.length();
  }

  size_t startIndex = remaining.length() > keepBytes ? remaining.length() - keepBytes : 0;
  // adjust to next newline boundary to ensure we keep whole rows
  int newlineAfter = remaining.indexOf('\n', startIndex);
  if (newlineAfter != -1 && (size_t)newlineAfter < remaining.length() - 1) {
    startIndex = newlineAfter + 1; // skip partial row
  } else if (startIndex > 0) {
    int newlineBefore = remaining.lastIndexOf('\n', startIndex);
    if (newlineBefore != -1 && (size_t)newlineBefore + 1 < remaining.length()) {
      startIndex = newlineBefore + 1;
    }
  }

  String trimmed = remaining.substring(startIndex);

  File out = LittleFS.open(dataPath, FILE_WRITE);
  if (!out) return;
  out.println(header);
  out.print(trimmed);
  out.close();
  Serial.println("Log file trimmed to maintain size limits.");
}

  String formatBytes(size_t bytes) {
    if (bytes < 1024) {
      return String(bytes) + " B";
    }
    double kb = bytes / 1024.0;
    if (kb < 1024.0) {
      return String(kb, 1) + " KB";
    }
    double mb = kb / 1024.0;
    return String(mb, 2) + " MB";
  }

  // Update system information
  void updateSystemInfo() {
    // Heap information
    uint32_t freeHeap = ESP.getFreeHeap();
    uint32_t totalHeap = ESP.getHeapSize();
    uint32_t usedHeap = totalHeap - freeHeap;
    freeHeapStr = formatBytes(freeHeap);
    totalHeapStr = formatBytes(totalHeap);
    usedHeapStr = formatBytes(usedHeap);
    
    // Flash information
    uint32_t flashSize = ESP.getFlashChipSize();
    uint32_t flashSpeed = ESP.getFlashChipSpeed() / 1000000; // Convert to MHz
    flashSizeStr = formatBytes(flashSize);
    flashSpeedStr = String(flashSpeed) + " MHz";
    
    // CPU frequency
    uint32_t cpuFreq = ESP.getCpuFreqMHz();
    cpuFreqStr = String(cpuFreq) + " MHz";
    
    // LittleFS storage
    size_t totalFS = LittleFS.totalBytes();
    size_t usedFS = LittleFS.usedBytes();
    size_t freeFS = totalFS > usedFS ? (totalFS - usedFS) : 0;
    
    littleFSTotalStr = totalFS > 0 ? formatBytes(totalFS) : "0 B";
    littleFSUsedStr = totalFS > 0 ? formatBytes(usedFS) : "0 B";
    littleFSFreeStr = totalFS > 0 ? formatBytes(freeFS) : "0 B";
    
    // Chip model - simplified approach
    chipModelStr = ESP.getChipModel();
    chipModelStr += " Rev" + String(ESP.getChipRevision());
    
    // Uptime
    unsigned long upMillis = millis();
    unsigned long upSeconds = upMillis / 1000;
    unsigned long upMinutes = upSeconds / 60;
    unsigned long upHours = upMinutes / 60;
    unsigned long upDays = upHours / 24;
    
    if (upDays > 0) {
      uptimeStr = String(upDays) + "d " + String(upHours % 24) + "h";
    } else if (upHours > 0) {
      uptimeStr = String(upHours) + "h " + String(upMinutes % 60) + "m";
    } else if (upMinutes > 0) {
      uptimeStr = String(upMinutes) + "m " + String(upSeconds % 60) + "s";
    } else {
      uptimeStr = String(upSeconds) + "s";
    }
  }

  String generateMinimalPage() {
    updateSystemInfo(); // Update system info before generating page
    String page = F(R"rawliteral(
  <!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>UlTeRa Space GPS · Direct Mode</title>
  <style>
  :root{color-scheme:dark light;}
  body{margin:0;font-family:'Segoe UI',Arial,sans-serif;background:#0b0d17;color:#f5f7ff;display:flex;flex-direction:column;min-height:100vh;}
  main{flex:1;display:flex;flex-direction:column;gap:18px;padding:32px;margin:0 auto;max-width:480px;}
  h1{margin:0;font-size:1.9rem;font-weight:600;}
  p{margin:0;color:#b0b9d9;line-height:1.6;}
  .card{background:rgba(15,23,42,0.55);border-radius:18px;padding:20px;box-shadow:0 24px 48px rgba(15,23,42,0.55);border:1px solid rgba(148,163,184,0.22);}
  label{display:block;text-transform:uppercase;font-size:0.75rem;letter-spacing:.15em;color:#9ea6c9;margin-top:12px;}
  .value{font-size:1.4rem;font-weight:600;margin-top:4px;color:#f8fbff;}
  a.btn{display:inline-flex;align-items:center;justify-content:center;padding:12px 24px;border-radius:999px;text-decoration:none;font-weight:600;background:#5c6cff;color:white;box-shadow:0 16px 32px rgba(92,108,255,0.35);margin-top:8px;}
  footer{padding:20px 32px;text-align:center;font-size:0.85rem;color:#7c86a7;}
  </style>
  </head>
  <body>
  <main>
    <h1>UlTeRa Space GPS</h1>
    <p>Device is operating in access point mode. It will automatically join trusted hotspots when they are in range.</p>
    <div class="card">
      <label>Latitude</label>
      <div class="value">{{LAT}}</div>
      <label>Longitude</label>
      <div class="value">{{LNG}}</div>
      <label>Last Fix</label>
      <div class="value">{{TIME}}</div>
    </div>
    <div class="card">
      <label>Speed (km/h)</label>
      <div class="value">{{SPEED}}</div>
      <label>Visible Satellites</label>
      <div class="value">{{SAT}}</div>
    </div>
    <a class="btn" href="/download">Download Latest CSV</a>
    <div class="card">
      <label>Current Hotspot</label>
      <div class="value">SSID: {{AP_SSID}}</div>
      <label>AP IP</label>
      <div class="value">{{AP_IP}}</div>
    </div>
    <div class="card">
      <label>Chip Model</label>
      <div class="value">{{CHIP_MODEL}}</div>
      <label>CPU Frequency</label>
      <div class="value">{{CPU_FREQ}}</div>
    </div>
    <div class="card">
      <label>Free Heap</label>
      <div class="value">{{FREE_HEAP}} / {{TOTAL_HEAP}}</div>
      <label>Flash Size</label>
      <div class="value">{{FLASH_SIZE}} @ {{FLASH_SPEED}}</div>
    </div>
    <div class="card">
      <label>LittleFS Storage</label>
      <div class="value">{{FS_FREE}} free of {{FS_TOTAL}}</div>
      <label>Uptime</label>
      <div class="value">{{UPTIME}}</div>
    </div>
  </main>
  <footer>Searching for trusted WiFi every {{SCAN_INTERVAL}} seconds.</footer>
  </body>
  </html>
  )rawliteral");
    page.replace("{{LAT}}", lastLat);
    page.replace("{{LNG}}", lastLng);
    page.replace("{{TIME}}", lastTime);
    page.replace("{{SPEED}}", lastSpeedKmph);
    page.replace("{{SAT}}", lastSatellites);
    page.replace("{{AP_SSID}}", String(ssid));
    page.replace("{{AP_IP}}", apIpStr);
    page.replace("{{SCAN_INTERVAL}}", String(WIFI_SCAN_INTERVAL_MS / 1000));
    page.replace("{{CHIP_MODEL}}", chipModelStr);
    page.replace("{{CPU_FREQ}}", cpuFreqStr);
    page.replace("{{FREE_HEAP}}", freeHeapStr);
    page.replace("{{TOTAL_HEAP}}", totalHeapStr);
    page.replace("{{FLASH_SIZE}}", flashSizeStr);
    page.replace("{{FLASH_SPEED}}", flashSpeedStr);
    page.replace("{{FS_FREE}}", littleFSFreeStr);
    page.replace("{{FS_TOTAL}}", littleFSTotalStr);
    page.replace("{{UPTIME}}", uptimeStr);
    return page;
  }

  String generateAdvancedPage() {
    updateSystemInfo(); // Update system info before generating page
    size_t fileSize = 0;
    if (LittleFS.exists(dataPath)) {
      File f = LittleFS.open(dataPath, FILE_READ);
      if (f) {
        fileSize = f.size();
        f.close();
      }
    }
    String page = F(R"rawliteral(
  <!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>UlTeRa Space GPS · Connected Dashboard</title>
  <style>
  :root{color-scheme:dark light;}
  body{margin:0;font-family:'Segoe UI',Arial,sans-serif;background:linear-gradient(135deg,#0f172a 0%,#1e293b 60%,#312e81 100%);color:#e2e8f0;min-height:100vh;}
  main{max-width:1100px;margin:0 auto;padding:32px 24px 64px;}
  header{display:flex;flex-direction:column;gap:8px;margin-bottom:28px;}
  h1{margin:0;font-size:2.2rem;font-weight:700;letter-spacing:0.02em;}
  .status-strip{display:flex;flex-wrap:wrap;gap:12px;}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:10px 18px;border-radius:999px;background:rgba(148,163,184,0.18);backdrop-filter:blur(10px);font-size:0.85rem;}
  .pill strong{color:#fff;}
  .grid{display:grid;gap:18px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));}
  .card{background:rgba(15,23,42,0.68);border-radius:22px;padding:22px;border:1px solid rgba(148,163,184,0.22);box-shadow:0 30px 60px rgba(15,23,42,0.55);backdrop-filter:blur(18px);}
  .card h2{margin:0 0 12px 0;font-size:0.95rem;text-transform:uppercase;letter-spacing:.18em;color:#94a3b8;}
  .metric{font-size:1.75rem;font-weight:600;color:#f8fafc;}
  .sub{margin-top:6px;color:#cbd5f5;font-size:0.85rem;}
  .actions{margin:28px 0;display:flex;flex-wrap:wrap;gap:12px;}
  .btn{display:inline-flex;align-items:center;gap:10px;padding:12px 22px;border-radius:999px;text-decoration:none;font-weight:600;transition:transform .2s,box-shadow .2s;background:#6366f1;color:white;box-shadow:0 18px 36px rgba(99,102,241,0.35);} 
  .btn:hover{transform:translateY(-1px);box-shadow:0 16px 30px rgba(99,102,241,0.45);} 
  .btn.secondary{background:rgba(148,163,184,0.22);color:#e2e8f0;box-shadow:none;}
  table{width:100%;border-collapse:collapse;background:rgba(15,23,42,0.6);border-radius:18px;overflow:hidden;}
  th,td{padding:12px 16px;text-align:left;border-bottom:1px solid rgba(148,163,184,0.18);font-size:0.95rem;}
  tr:last-child td{border-bottom:none;}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border-radius:999px;font-size:0.8rem;font-weight:600;background:rgba(34,197,94,0.18);color:#4ade80;}
  .badge.offline{background:rgba(248,113,113,0.2);color:#fca5a5;}
  </style>
  </head>
  <body>
  <main>
    <header>
      <h1>UlTeRa Space GPS · Mission Dashboard</h1>
      <div class="status-strip">
        <span class="pill">Hotspot: <strong>{{WIFI_SSID}}</strong> · IP <span id="wifiIp">{{WIFI_IP}}</span></span>
        <span class="pill">Local AP <strong>{{AP_SSID}}</strong> · {{AP_IP}}</span>
        <span class="pill">Logs trimmed above {{MAX_SIZE}} KB · Threshold {{TRIM_THRESHOLD}}%</span>
        <span class="pill">Heartbeat ≤ {{HEARTBEAT}} s</span>
      </div>
    </header>
    <section class="grid">
      <div class="card">
        <h2>Position</h2>
        <div class="metric"><span id="lat">{{LAT}}</span>°</div>
        <div class="metric"><span id="lng">{{LNG}}</span>°</div>
        <p class="sub">Updated <span id="lastTime">{{TIME}}</span></p>
      </div>
      <div class="card">
        <h2>Motion</h2>
        <div class="metric"><span id="speed">{{SPEED}}</span> km/h</div>
        <p class="sub">Course <span id="course">{{COURSE}}</span>°</p>
      </div>
      <div class="card">
        <h2>Altitude</h2>
        <div class="metric"><span id="altitude">{{ALT}}</span> m</div>
        <p class="sub">HDOP <span id="hdop">{{HDOP}}</span></p>
      </div>
      <div class="card">
        <h2>Satellites</h2>
        <div class="metric"><span id="satellites">{{SAT}}</span></div>
        <p class="sub">Fix age <span id="fixAge">{{FIXAGE}}</span> ms</p>
      </div>
    </section>
    <section class="actions">
      <a class="btn" href="/download">Download CSV</a>
      <a class="btn secondary" href="/data.json" target="_blank">Open Real-time JSON</a>
    </section>
    <table>
      <tbody>
        <tr><th>WiFi Link</th><td><span id="connectionBadge" class="badge">Online</span></td><td id="linkNote">Connected to {{WIFI_SSID}}</td></tr>
        <tr><th>Log File</th><td>{{FILE_SIZE}}</td><td>Auto trims beyond {{MAX_SIZE}} KB</td></tr>
        <tr><th>AP Access</th><td>{{AP_SSID}} · {{AP_IP}}</td><td>Use direct AP when hotspot unavailable</td></tr>
      </tbody>
    </table>
    <h2 style="margin:32px 0 12px;font-size:1.2rem;letter-spacing:0.1em;text-transform:uppercase;color:#94a3b8;">System Information</h2>
    <table>
      <tbody>
        <tr><th>Chip Model</th><td>{{CHIP_MODEL}}</td><td>CPU @ {{CPU_FREQ}}</td></tr>
        <tr><th>Memory (Heap)</th><td>{{FREE_HEAP}} free / {{TOTAL_HEAP}} total</td><td>{{USED_HEAP}} in use</td></tr>
        <tr><th>Flash Memory</th><td>{{FLASH_SIZE}}</td><td>Running @ {{FLASH_SPEED}}</td></tr>
        <tr><th>LittleFS Storage</th><td>{{FS_USED}} used / {{FS_TOTAL}} total</td><td>{{FS_FREE}} available</td></tr>
        <tr><th>System Uptime</th><td>{{UPTIME}}</td><td>Since last reboot</td></tr>
      </tbody>
    </table>
  </main>
  <script>
  const connectionBadge=document.getElementById('connectionBadge');
  const linkNote=document.getElementById('linkNote');
  function setBadge(online,ssid){
    if(online){connectionBadge.classList.remove('offline');connectionBadge.textContent='Online';linkNote.textContent='Connected to '+(ssid||'—');}
    else{connectionBadge.classList.add('offline');connectionBadge.textContent='Offline';linkNote.textContent='Awaiting known hotspot';}
  }
  async function refresh(){
    try{
      const res=await fetch('/data.json');
      if(!res.ok) return;
      const data=await res.json();
      document.getElementById('lat').textContent=data.lat;
      document.getElementById('lng').textContent=data.lng;
      document.getElementById('lastTime').textContent=data.time;
      document.getElementById('speed').textContent=data.speedKmph;
      document.getElementById('course').textContent=data.courseDeg;
      document.getElementById('altitude').textContent=data.altMeters;
      document.getElementById('hdop').textContent=data.hdop;
      document.getElementById('satellites').textContent=data.satellites;
      document.getElementById('fixAge').textContent=data.fixAgeMs;
      document.getElementById('wifiIp').textContent=data.wifiIp;
      setBadge(data.wifiConnected, data.wifiSsid);
    }catch(err){console.log(err);}
  }
  setBadge(true,'{{WIFI_SSID}}');
  setInterval(refresh,4000);
  </script>
  </body>
  </html>
  )rawliteral");
    page.replace("{{WIFI_SSID}}", stationConnected ? currentStationSsid : String("Not connected"));
    page.replace("{{WIFI_IP}}", stationIpStr);
    page.replace("{{AP_SSID}}", String(ssid));
    page.replace("{{AP_IP}}", apIpStr);
    page.replace("{{TRIM_THRESHOLD}}", String(STORAGE_HIGH_WATERMARK * 100.0f, 0));
    page.replace("{{HEARTBEAT}}", String(LOG_MAX_INTERVAL_MS / 1000));
    page.replace("{{LAT}}", lastLat);
    page.replace("{{LNG}}", lastLng);
    page.replace("{{TIME}}", lastTime);
    page.replace("{{SPEED}}", lastSpeedKmph);
    page.replace("{{COURSE}}", lastCourseDeg);
    page.replace("{{ALT}}", lastAltitudeMeters);
    page.replace("{{HDOP}}", lastHdop);
    page.replace("{{SAT}}", lastSatellites);
    page.replace("{{FIXAGE}}", lastFixAgeMs);
    page.replace("{{FILE_SIZE}}", formatBytes(fileSize));
    page.replace("{{MAX_SIZE}}", String(static_cast<int>(MAX_LOG_FILE_SIZE / 1024)));
    page.replace("{{CHIP_MODEL}}", chipModelStr);
    page.replace("{{CPU_FREQ}}", cpuFreqStr);
    page.replace("{{FREE_HEAP}}", freeHeapStr);
    page.replace("{{TOTAL_HEAP}}", totalHeapStr);
    page.replace("{{USED_HEAP}}", usedHeapStr);
    page.replace("{{FLASH_SIZE}}", flashSizeStr);
    page.replace("{{FLASH_SPEED}}", flashSpeedStr);
    page.replace("{{FS_USED}}", littleFSUsedStr);
    page.replace("{{FS_TOTAL}}", littleFSTotalStr);
    page.replace("{{FS_FREE}}", littleFSFreeStr);
    page.replace("{{UPTIME}}", uptimeStr);
    return page;
  }

  void handleDataJson(AsyncWebServerRequest *request) {
    updateSystemInfo(); // Update system info before sending JSON
    size_t fileSize = 0;
    if (LittleFS.exists(dataPath)) {
      File f = LittleFS.open(dataPath, FILE_READ);
      if (f) {
        fileSize = f.size();
        f.close();
      }
    }
    String json = "{";
    json += "\"lat\":\"" + lastLat + "\",";
    json += "\"lng\":\"" + lastLng + "\",";
    json += "\"time\":\"" + lastTime + "\",";
    json += "\"speedKmph\":\"" + lastSpeedKmph + "\",";
    json += "\"altMeters\":\"" + lastAltitudeMeters + "\",";
    json += "\"courseDeg\":\"" + lastCourseDeg + "\",";
    json += "\"satellites\":\"" + lastSatellites + "\",";
    json += "\"hdop\":\"" + lastHdop + "\",";
    json += "\"fixAgeMs\":\"" + lastFixAgeMs + "\",";
    json += "\"wifiConnected\":" + String(stationConnected ? "true" : "false") + ",";
    json += "\"wifiSsid\":\"" + (stationConnected ? currentStationSsid : String("")) + "\",";
    json += "\"wifiIp\":\"" + stationIpStr + "\",";
    json += "\"apIp\":\"" + apIpStr + "\",";
    json += "\"logSizeBytes\":" + String((unsigned long)fileSize) + ",";
    json += "\"maxLogBytes\":" + String((unsigned long)MAX_LOG_FILE_SIZE) + ",";
    json += "\"chipModel\":\"" + chipModelStr + "\",";
    json += "\"cpuFreq\":\"" + cpuFreqStr + "\",";
    json += "\"freeHeap\":\"" + freeHeapStr + "\",";
    json += "\"totalHeap\":\"" + totalHeapStr + "\",";
    json += "\"usedHeap\":\"" + usedHeapStr + "\",";
    json += "\"flashSize\":\"" + flashSizeStr + "\",";
    json += "\"flashSpeed\":\"" + flashSpeedStr + "\",";
    json += "\"fsUsed\":\"" + littleFSUsedStr + "\",";
    json += "\"fsTotal\":\"" + littleFSTotalStr + "\",";
    json += "\"fsFree\":\"" + littleFSFreeStr + "\",";
    json += "\"uptime\":\"" + uptimeStr + "\"";
    json += "}";
    request->send(200, "application/json", json);
  }

// Check storage usage and rotate/cleanup if needed
void manageStorageIfNeeded() {
  unsigned long now = millis();
  if (now - lastStorageCheckMillis < STORAGE_CHECK_INTERVAL_MS) return;
  lastStorageCheckMillis = now;

  size_t total = 0;
  size_t used = 0;
  
  // Get LittleFS stats directly
  total = LittleFS.totalBytes();
  used = LittleFS.usedBytes();

  float usedFrac = 0.0;
  if (total > 0) {
    usedFrac = (float)used / (float)total;
    Serial.printf("Storage used: %u / %u (%.1f%%)\n", (unsigned)used, (unsigned)total, usedFrac * 100.0);
  } else {
    Serial.println("Warning: LittleFS reports 0 total bytes");
  }

  bool trimmed = false;
  if (LittleFS.exists(dataPath)) {
    File f = LittleFS.open(dataPath, FILE_READ);
    if (f) {
      size_t sz = f.size();
      f.close();
      if (sz >= MAX_LOG_FILE_SIZE) {
        trimLogFile();
        trimmed = true;
      }
    }
  }

  if (!trimmed && total > 0 && usedFrac >= STORAGE_HIGH_WATERMARK) {
    trimLogFile();
    trimmed = true;
    #ifdef __ESP32__
    used = LittleFS.usedBytes();
    usedFrac = total > 0 ? (float)used / (float)total : 0.0f;
    #endif
  }

  if (total > 0 && usedFrac >= STORAGE_HIGH_WATERMARK) {
    Serial.println("Storage critically full, clearing current log file.");
    if (LittleFS.exists(dataPath)) {
      LittleFS.remove(dataPath);
    }
    File file = LittleFS.open(dataPath, FILE_WRITE);
    if (file) {
      file.println(CSV_HEADER);
      file.close();
    }
  }
}

// Function to append data to CSV file
void appendFile(fs::FS &fs, const char * path, const char * message) {
  Serial.printf("Appending to file: %s\n", path);
  File file = fs.open(path, FILE_APPEND);
  if (!file) {
    Serial.println("Failed to open file for appending");
    return;
  }
  if (file.print(message)) {
    Serial.println("Message appended");
  } else {
    Serial.println("Append failed");
  }
  file.close();
}

// Handle root page (show last location)
void handleRoot(AsyncWebServerRequest *request) {
  if (stationConnected) {
    request->send(200, "text/html", generateAdvancedPage());
  } else {
    request->send(200, "text/html", generateMinimalPage());
  }
}

// Handle CSV download
void handleDownload(AsyncWebServerRequest *request) {
  if (LittleFS.exists(dataPath)) {
    request->send(LittleFS, dataPath, "text/csv", true);
  } else {
    request->send(404, "text/plain", "File not found");
  }
}

void setup() {
  // Serial.begin(115200); //comment for production
  Serial.println("Starting ESP32 GPS Datalogger (Async)...");

  // Initialize GPS Serial
  gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);
  Serial.println("GPS Serial started");

  // Initialize LittleFS
  Serial.println("Mounting LittleFS...");
  if (!LittleFS.begin(false)) {
    Serial.println("LittleFS mount failed, formatting...");
    if (!LittleFS.begin(true)) {
      Serial.println("LittleFS format failed!");
      return;
    }
  }
  Serial.println("LittleFS initialized");
  
  // Print LittleFS info
  size_t totalBytes = LittleFS.totalBytes();
  size_t usedBytes = LittleFS.usedBytes();
  Serial.printf("LittleFS: Total=%u, Used=%u, Free=%u\n", 
                (unsigned)totalBytes, (unsigned)usedBytes, (unsigned)(totalBytes - usedBytes));
  
  delay(100); // Give LittleFS time to fully initialize

  // Create CSV header if file doesn't exist
  if (!LittleFS.exists(dataPath)) {
    File file = LittleFS.open(dataPath, FILE_WRITE);
    if (file) {
      file.println(CSV_HEADER);
      file.close();
      Serial.println("CSV header created");
    }
  }

  // Initialize LED pin
  pinMode(LED_PIN, OUTPUT);

  // Configure WiFi (AP + STA)
  WiFi.mode(WIFI_AP_STA);
  WiFi.persistent(false);
  WiFi.setAutoReconnect(true);
  WiFi.onEvent(onWiFiEvent);

  WiFi.softAP(ssid, password);
  apIpStr = WiFi.softAPIP().toString();
  Serial.printf("AP SSID: %s | IP: %s\n", ssid, apIpStr.c_str());

  WiFi.disconnect(true);
  delay(100);
  lastWifiScanMillis = millis();
  attemptConnectToKnownNetworks();

  // Delay first storage check to avoid startup blocking
  lastStorageCheckMillis = millis() + 30000UL; // First check after 30 seconds

  // Setup async web server routes
  server.on("/", HTTP_GET, handleRoot);
  server.on("/data.json", HTTP_GET, handleDataJson);
  server.on("/download", HTTP_GET, handleDownload);
  server.begin();
  Serial.println("Async Web server started");
}

void loop() {
  // Read GPS data (non-blocking)
  while (gpsSerial.available() > 0) {
    digitalWrite(LED_PIN, HIGH);
    gps.encode(gpsSerial.read());
  }
  digitalWrite(LED_PIN, LOW);   // Turn OFF LED after reading
  // Check for location update
  if (gps.location.isUpdated()) {
    double curLat = gps.location.lat();
    double curLng = gps.location.lng();
    lastLat = String(curLat, 6);
    lastLng = String(curLng, 6);
    lastTime = String(gps.date.year()) + "/" + 
               String(gps.date.month()) + "/" + 
               String(gps.date.day()) + " " + 
               String(gps.time.hour()) + ":" + 
               String(gps.time.minute()) + ":" + 
               String(gps.time.second());

    if (gps.speed.isValid()) {
      lastSpeedKmph = String(gps.speed.kmph(), 2);
    } else {
      lastSpeedKmph = "N/A";
    }
    if (gps.altitude.isValid()) {
      lastAltitudeMeters = String(gps.altitude.meters(), 1);
    } else {
      lastAltitudeMeters = "N/A";
    }
    if (gps.course.isValid()) {
      lastCourseDeg = String(gps.course.deg(), 1);
    } else {
      lastCourseDeg = "N/A";
    }
    if (gps.satellites.isValid()) {
      lastSatellites = String(gps.satellites.value());
    } else {
      lastSatellites = "0";
    }
    if (gps.hdop.isValid()) {
      lastHdop = String(gps.hdop.hdop(), 1);
    } else {
      lastHdop = "N/A";
    }
    lastFixAgeMs = String(gps.location.age());

    unsigned long now = millis();
    bool shouldLog = false;
    // If we never logged before, log
    if (!hasLastLogged) {
      shouldLog = true;
    } else {
      // distance-based threshold
      double dist = haversineDistance(lastLoggedLat, lastLoggedLng, curLat, curLng);
      if (dist >= SIGNIFICANT_DISTANCE_METERS) {
        shouldLog = true;
      }
      // periodic heartbeat: log even if small movement after max interval
      if (!shouldLog && (now - lastLoggedMillis >= LOG_MAX_INTERVAL_MS)) {
        shouldLog = true;
      }
    }
    if (shouldLog) {
      // Prepare CSV row
      String dataMessage = lastTime + "," + 
                           String(curLat, 6) + "," + 
                           String(curLng, 6) + "," + 
                           String(gps.altitude.meters()) + "," + 
                           String(gps.speed.kmph()) + "," + 
                           String(gps.satellites.value()) + "\r\n";

      // Append to file
      appendFile(LittleFS, dataPath, dataMessage.c_str());

      // Update last logged state
      hasLastLogged = true;
      lastLoggedLat = curLat;
      lastLoggedLng = curLng;
      lastLoggedMillis = now;

      // Debug output
      Serial.println("GPS Logged: " + dataMessage);
    } else {
      Serial.println("Change not significant, skipping log.");
    }
  }

  if (gps.location.isValid()) {
    lastFixAgeMs = String(gps.location.age());
  } else {
    lastFixAgeMs = "Invalid";
  }

  // Keep WiFi policy responsive
  maintainWiFi();

  // Periodically check storage and rotate if necessary
  manageStorageIfNeeded();

  delay(100);  // Small delay to prevent overwhelming the serial
}